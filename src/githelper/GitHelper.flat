package githelper

import flat/system/ExecutionResponse
import flat/log/Logger
import flat/io/File
import flat/git/Git
import flat/git/Git.PullResponse

class {
  static Logger log = Logger(GitHelper.class)

  public static async pullAll(
    File[] repoDirectories,
    Bool: sync = false
  ) {
    let gits = repoDirectories.map({ Git(_) })

    var GitResponse<Git.PullResponse>[] responses

    if (sync) {
      responses = gits.mapAsync((git) => {
        log.info("Pulling repo #{git.workingDirectory.nativeLocation}")
        return GitResponse(git.workingDirectory, git.pull(silent: true))
      })
    } else {
      responses = gits.mapParallel((git) => {
        log.info("Pulling repo #{git.workingDirectory.nativeLocation}")
        return GitResponse(git.workingDirectory, git.pull(silent: true))
      })
    }

    responses
      .filter({ _.response.success })
      .forEach((value) => {
        log.info("Repo \"#{value.repoDirectory.nativeLocation}\" #{value.response.upToDate ? "already up to date" : "updated"}.")
      })

    responses
      .filter({ !_.response.success })
      .forEach((value) => {
        log.error("|
          Error pulling repo \"#{value.repoDirectory.nativeLocation}\":
          \t#{value.response.toString().indent(1)}
          |")
      })

    log.info("Finished")
  }

  public static async cloneAll(
    String organization,
    File[] repoDirectories,
    Bool: sync = false
  ) {
    var GitResponse<ExecutionResponse>[] responses

    if (sync) {
      responses = repoDirectories.mapAsync((directory) => {
        let repoUrl = "https://github.com/#{organization}/#{directory.name}"
        log.info("Cloning repo #{repoUrl} into #{directory.getCanonicalPath()}")
        return GitResponse(directory, Git.clone(repoUrl, outputDirectory: directory.getCanonicalPath(), silent: true))
      })
    } else {
      responses = repoDirectories.mapParallel((directory) => {
        let repoUrl = "https://github.com/#{organization}/#{directory.name}"
        log.info("Cloning repo #{repoUrl} into #{directory.getCanonicalPath()}")
        return GitResponse(directory, Git.clone(repoUrl, outputDirectory: directory.getCanonicalPath(), silent: true))
      })
    }

    responses
      .filter({ _.response.exitCode == 0 })
      .forEach((value) => {
        log.info("Repo \"#{value.repoDirectory.nativeLocation}\" cloned.")
      })

    responses
      .filter({ _.response.exitCode != 0 })
      .forEach((value) => {
        log.error("|
          Error cloning repo \"#{value.repoDirectory.nativeLocation}\":
          \t#{value.response.toString().indent(1)}
          |")
      })

    log.info("Finished")
  }

  public static async execAll(
    String[] commands,
    File[] repoDirectories,
    Bool: sync = false
  ) {
    var GitResponse<ExecutionResponse>[] responses

    if (sync) {
      responses = repoDirectories.mapAsync((directory) => {
        log.info("Executing command \"#{commands}\" in directory #{directory.getCanonicalPath()}")
        return GitResponse(directory, System.execute(commands, workingDirectory: directory.getCanonicalPath(), silent: true))
      })
    } else {
      responses = repoDirectories.mapParallel((directory) => {
        log.info("Executing command \"#{commands}\" in directory #{directory.getCanonicalPath()}")
        return GitResponse(directory, System.execute(commands, workingDirectory: directory.getCanonicalPath(), silent: true))
      })
    }

    responses
      .filter({ _.response.exitCode == 0 })
      .forEach((value) => {
        log.info("Executed command in repo \"#{value.repoDirectory.nativeLocation}\" executed.")
      })

    responses
      .filter({ _.response.exitCode != 0 })
      .forEach((value) => {
        log.error("|
          Error executing command in repo \"#{value.repoDirectory.nativeLocation}\":
          \t#{value.response.toString().indent(1)}
          |")
      })

    log.info("Finished")
  }

  class GitResponse<TResponse> {
    public construct(
      visible File repoDirectory,
      visible TResponse response
    ) {}
  }
}
